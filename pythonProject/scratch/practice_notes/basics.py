x = 56
y = 279.99
discount = 0.13
price = y * (1 - discount)
print(price)

name = "Jas"
greeting = f"Hello {name}"
print(greeting)
name = "Singh"
greeting1 = "Hello {}, from {}"
new_greeting = greeting1.format(name, "MH")
print(new_greeting)

# name = input("type your name? :")
print(f"nice to meet you {name}")

# size_in_feet = input("Whats sqft are of house?: ")
size_in_feet = "2325"
meters = int(size_in_feet) / 10.8
print(f"House size in meters: {meters:.3f}")  # restricts decimals to defined count

#age_years = int(input("How many years old are you? "))
age_years = 39
age_months = age_years * 12
age_days = int(age_years) * 365
print(f"\n You are {age_months} months or {age_days} days by now")

listA = ["a", "b", "c"]  # order stays maintained
tupleA = ("a", "b", "c")  # immutable, can't delete or update values, order maintained
setA = {"a", "b", "c"}  # no duplicate values allowed, order not maintained

listA[1] = "d"  # updates value
print(f"list after update: {listA}")
listA.append("e")  # appends at the end
print(f"list after append: {listA}")
listA.remove("d")
print(f"list after delete: {listA}")
setA.add("d")  # set has add, NOT append, as set has no order, so no way to add at end
print(f"set after add: {setA}")
setA.add("a")  # set ignores duplicate value
print(f"set after add: {setA}")  # so you see a just once despite trying to add it

# Advanced set operations to know y sets r useful
friends = {"a", "b", "c"}
abroad = {"b", "c"}
local = {"a"}  # instead of writing leftover like this
localA = friends.difference(abroad)
localB = abroad.difference(friends)
print(f"Bigger minus Smaller: {localA}")
print(f"Smaller minus Bigger: {localB}")  # this will show notation of empty set
f1 = {"a", "b", "c"}
f2 = {"c", "d"}
f1f2_add = f1.union(f2)
print(f"f1 n f2 added : {f1f2_add}")
f1f2_intersect = f1.intersection(f2)
print(f"f1 n f1 common : {f1f2_intersect}")

# booleans
print(7 == 7)
print(7 == "7")
print(7 != "7")

l1 = ["a", "b"]
l2 = ["a", "b"]
print(l1 == l2)  # true, cuz it compares elements of lists
print(l1 is l2)  # false cuz it compares names of objects (lists in this case)
print("l1 ID:", id(l1), "\nl2 ID:", id(l2))  # these IDs are r related to memory address

# day_of_week = input("What day is today?").lower()  # helps ignore case sensitivity
day_of_week = "MoNDaY"
if day_of_week == "monday":
    print("start of week")
elif day_of_week == "tuesday":
    print("going strong")
else:
    print("have fun")

# in keyword used for membership or present in lists or tuples
print("c" in f2)
print("f" in f2)
print("ll" in greeting)

# conditional statements
answer = 8
# game = input("Wanna play guess game? ").lower()
game = "y"
if game == "y":
    #    number = int(input("Guess a number: "))
    number = 8
    if number == answer:
        print("jackpot!")
    elif abs(number - answer) == 1:
        print("quite close by 1")
    else:
        print("wrong!")

# loops
# for infinite loop, set while True:
# and then use if condition n break statement, to break out of the loop

grades = [35, 67, 98, 100, 100]
total = 0
count = len(grades)
for grade in grades:
    total += grade
print(f"Average: ", total / count)
# instead of using for loop above, use sum math function
total = sum(grades)
print(f"Average: ", total / count)

# to find even no.s, user remainder symbol %, i.e., x % 2 == 0

# list comprehensions -- allow new lists to create out of existing lists
list1 = [1, 3, 5]
list2 = [x * 2 for x in list1]  # to add values double of list1
print(list2)

# find names that start wid s
listA = ["abc", "sabc", "xyz", "sxyz", "stsla"]
listB = [x for x in listA if x.startswith("s")]
print(listB)

# dictionaries
d1 = {"a": 10, "b": 25, "c": 37}
listofdicts = [
    {"age": 10, "name": "Jas"},
    {"age": 25, "name": "Jz"},
    {"age": 37, "name": "Sun"}
]

print(d1["b"])
print(listofdicts[2]["name"])

for name, number in d1.items():
    print(f"Name: {name} | Number: {number}")

# `items()` method gives a list of tuples,
#           each tuple containing a key-value pair
# as items() returns tuples, output can also be extracted wid subscripts, i.e.,
for name in d1.items():
    print(f"Name: {name[0]} :: Number: {name[1]}")

# so, above for-loop can be avoided n replaced as below
print(list(d1.items()))  # dict is type-casted into list n returns
#                              list of tuples, generated by items()

# using in keyword, can check ONLY keys, NOT values.

# de-structuring variables
x = 5, 11  # python treats this as a tuple by default
print(type(x))
y = [5, 11]  # list
z = [(5, 11)]  # tuple inside a list
x, y = 5, 11  # shorthand for defining two vars separately, i.e., x=5 n y=11
tupleB = 5, 11
x, y = tupleB  # python assigns individual elements of tuple to vars
print(x, y)

# vars can start wid underscore (_)
# so, if any specific values needs to be ignored,
#     variable for that value can be named as _
#     informs that this variable/value is a placeholder, meant to be ignored
# Example:
person = ("Jas", "200", "39", "172")
name, _, age, height = person
print(name, age, height)

# in below case, all values except 1st get into *var
head, *tail = [1, 2, 3, 4, 5]  # *var helps store leftover values
print(head)
print(tail)

# now in below case, all values except last get into *var
*head, tail = [1, 2, 3, 4, 5]  # *var helps store leftover values
print(tail)
print(head)

# *, if used inside print, treats it as separate values n not as list
print(*head)


# functions : function is a callable variable, that won;t execute unless invoked
# same wid variable; gets value assigned but doesn't get executed till invoked
# so basically defining a function doesn't run a function

# sequence of python execution for a function >>


def hello():  # python interprets this 1st n ignored function body
    print("Hello!")  # python runs this after function is invoked


hello()  # upon invocation, python runs this next
#                      and then jumps to function body
age = 39


def age_in_seconds():
    age_seconds = age * 365 * 24 * 60 * 60
    print(f"Your age in seconds is {age_seconds} seconds")


age_in_seconds()

# Don'ts in function
# 1. DO NOT overshadow global variable inside function scope
# 2. function cant be invoked before its definition
varA = 10


# def functa():
#    print("am inside function")
#    varA = varA + 5  # overriding global scope variable
# python creates space for new local variable, that shadows/overrides global var
# but since name is same for both global n local gives error like >>
# UnboundLocalError: cannot access local variable 'varA' where it is not associated with a value
#    print(f"value: {varA}")


# functa()   # will give above-specified error, if uncommented

# while coding, good practice to write pass inside function, when
# you know you need a function, but yet to decide what to put in function body


def add(x, y):  # Here, 5, 3 are called parameters
    print(f"x = {x}, y = {y}, sum = {x + y}")


add(5, 3)  # Here, 5,3 r called arguments
# vars passed to function are created only during function invocation

# positional parameter/argument means definition & assignments based on position
# so, in above function, 5 is assigned to x; both at 1st position, n 3 to y
# so, position of argument affects value for parameter.
# keyword or named arguments are NOT positional. Example:
add(y=4, x=7)
# named arguments are very widely-used in python
# use named/keyword arguments wenevr possible to make code look easier to understand
# in a mix, positional arguments have to go 1st n then named arguments
add(5, y=3)  # works correctly


# add(x=4, 9)  # triggers error
# SyntaxError: positional argument follows keyword argument

# if you call a function with lesser arguments than number of parameters
# in the function definition,
# Python throws a `TypeError` indicating that the function is missing
# some required positional arguments.

# default pmtr values
# again, positional pmtr should be defined BEFORE default value declared

def multiply(x, y=9):  # makes y as optional now, with x still being required
    print(f"x={x}, y={y}, multiplication={x * y}")


multiply(7)
multiply(7, 6)

default_y = 8


def multiply(x, y=default_y):
    print(f"x={x}, y={y}, multiplication={x * y}")


multiply(6)
default_y = 5
multiply(6)  # will still give same result cuz default set at function creation
#               time, doesn't gets overridden later on

# functions returning values
# None is a spl value, meaning no value, missing or undeclared value
multiply(5)
result = multiply(5)
print(result)  # gives None, as thats default return value, if not specified


def divide(x, y=2):
    if y != 0:
        return x / y
    else:
        return f"divisor can't be 0"


divide(7)
result = divide(7)
print(result)
print(divide(7))
print(divide(7, 0))
print(divide(7, -2))
# return terminates the function, anything specified after return is ignored

# lambda functions, not vry common, usually we define fns
# its a diff. type of fn that doesnt has a name & is only used to return values
add_lambda = (lambda x, y: x + y)(6, 7)
print(add_lambda)
print((lambda x, y: x * y)(3, 7))


def double(x):
    return x * 2


# diff. ways to achieve same thing, ur choice to pick most optimal
sequence = [2, 3, 6, 8, 9]
doubled = [x * 3 for x in sequence]  # list comprehension
doubled1 = [double(x) for x in sequence]  # list comprehension wid fn
doubled3 = [(lambda x: x * 7)(x) for x in sequence]  # list comprehension wid fn
doubled2 = list(map(lambda x: x * 5, sequence))  # pre-defined map fn using lambda
print(doubled, doubled1, doubled2, doubled3, sep='\n')

# list comprehension is faster than map
# only scenario whr map can be preferred is, if other lang.s do not support list comprehension
# lambda fns are difficult to trak of, once programs grow

# dictionary comprehensions
users = [
    (0, "a", "passwd142"),
    (1, "b", "passwd231"),
    (2, "c", "passwd876"),
    (3, "d", "passwd823")
]
dictA = {user[1]: user for user in users}  # dictionary comprehension
# helps store user-specific key-value pairs
print(dictA)
# basic login auth can be performed using this like >>
# username = input("Enter you login ID: ")
# passwd = input("Enter password: ")
username = "a"
passwd = "passwd142"
_, name, pwd = dictA[username]
if pwd == passwd:
    print("Login successful")
else:
    print("Login failed")

# ===============================================================
# ============= Exercise ========================================
# ===============================================================
# Create a variable called student, with a dictionary.
# The dictionary must contain three keys: 'name', 'school', and 'grades'.
# The values for each must be 'Jose', 'Computing', and a tuple with the values 66, 77, and 88.
student = {
    "name": "Jose",
    "school": "Computing",
    "grades": (66, 77, 88)
}

student1 = {
    "name": "Jose",
    "school": "Tech",
    "grades": (53, 83, 96)
}

student_list = [student, student1]


# Assume the argument, data, is a dictionary.
# Modify the grades variable so it accesses the 'grades' key of the data dictionary.
def average_grade(data):
    grades = data['grades']
    return sum(grades) / len(grades)


# Implement the function below
# Given a list of students (a list of dictionaries), calculate the average grade received on an exam, for the entire class
# You must add all the grades of all the students together
# You must also count how many grades there are in total in the entire list
def average_grade_all_students(student_list):
    total = 0
    count = 0
    for student in student_list:
        total += sum(student['grades'])
        count += len(student['grades'])

    return total / count


print(average_grade_all_students(student_list))


# ===============================================================
# ===============================================================

# unpacking args


def multiply(*args):  # define multiply fn that takes any no. of args
    print(args)
    total = 1
    for arg in args:
        total *= arg
    return total


def apply(*args, operator):
    if operator == "+":
        print(args)
        return sum(args)
    elif operator == "*":
        #return multiply(args)  # returns tuple of tuples, cuz it takes no. as a tuple
        return multiply(*args)  # to fix it, use * here as well
    else:
        return "specify valid operator as operator=+ or *"


print(multiply(3, 5, 4, 6, 7, 9))
numbers = [-1, -3, -5]
print(multiply(*numbers))  # can invoke this way as well
print(apply(1, 7, 6, 3, operator="+"))
print(apply(9, 4, 7, 2, operator="*"))

dictB = {
    "x": 5,
    "y": 9
}
add(x=dictB["x"], y=dictB["y"])  # instead of hard-coding n making this complex
add(**dictB)  # 2 asterisks can be used when
#                                  pmtr name of fn is same as key in dict.
#                                  very helpful in larger dictionaries

# unpacking keyword args
# keyword/named args r collected n put into dictionary

def named(*args):
    print(args)

def named1(**args):
    print(args)


def named2(**kwargs):
    print(kwargs)


def nice_output(**kwargs):
    named2(**kwargs)
    print("nicer")
    for arg, value in kwargs.items():
        print(f"{arg}: {value}")


#named(name="Jas", age=39)
named1(name="Jas", age=39)
named2(name="Jas", age=39)
nice_output(name="jas", age=39)
details = {
    "name": "Jas",
    "age": 39
}
#named(**details)
named1(**details)
named2(**details)
nice_output(**details)


def both(*args, **kwargs):  # this syntax is used to accept unlimited no. of args
    print(args)
    print(kwargs)


both(1, 2, 3, 5, name="Jas", age=39)

# *args    collects positional args in a tuple
# **kwargs collects named      args in a dictionary

# common example of above-defined both fn, is API fns like this >>
"""
def post(url, data=None, json=None, **kwargs):
    return request('post', url, data=data, json=json, **kwargs)
"""
