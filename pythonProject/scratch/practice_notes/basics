===========================================
Read more abt wraps
Read more about usage of *args & **kwargs
===========================================


Wht is diff b/w .items() and .values() ?
  .keys()   -- returns all keys
  .values() -- returns all values
  .items()  -- returns key-value pairs in tuples

dict1 |= dict2 # << contents of dict2 overwrite contents of dict1

greeting = f"Hello {name}"

name = "Singh"
greeting1 = "Hello {}, from {}"
new_greeting = greeting1.format(name, "MH")

print(f"House size in meters: {meters:.3f}")  # restricts decimals to defined count

setA.add("d")  # set has add, NOT append, as set has no order, so no way to add at end
localA = friends.difference(abroad)
localB = abroad.difference(friends)
print(f"Bigger minus Smaller: {localA}")
print(f"Smaller minus Bigger: {localB}")  # this will show notation of empty set
f1f2_add = f1.union(f2)
print(f"f1 n f2 added : {f1f2_add}")
f1f2_intersect = f1.intersection(f2)
print(f"f1 n f1 common : {f1f2_intersect}")

print(l1 == l2)  # true, cuz it compares elements of lists
print(l1 is l2)  # false cuz it compares names of objects (lists in this case)
print("l1 ID:", id(l1), "\nl2 ID:", id(l2))  # these IDs are r related to memory address

# day_of_week = input("What day is today?").lower()  # helps ignore case sensitivity

elif abs(number - answer) == 1:

print(f"Average: ", sum(grades) / len(grades))

# to find even no.s, user remainder symbol %, i.e., x % 2 == 0

list2 = [x * 2 for x in list1]  # to add values double of list1
listB = [x for x in listA if x.startswith("s")]

listofdicts = [
    {"age": 10, "name": "Jas"},
    {"age": 25, "name": "Jz"},
    {"age": 37, "name": "Sun"}
]
print(listofdicts[2]["name"])

for name, number in d1.items():
    print(f"Name: {name} | Number: {number}")

# `items()` method gives a list of tuples,
#           each tuple containing a key-value pair
# as items() returns tuples, output can also be extracted wid subscripts, i.e.,
for name in d1.items():
    print(f"Name: {name[0]} :: Number: {name[1]}")

# so, above for-loop can be avoided n replaced as below
print(list(d1.items()))  # dict is type-casted into list n returns
#                              list of tuples, generated by items()

# using in keyword, can check ONLY keys, NOT values.

x = 5, 11  # python treats this as a tuple by default

y = [5, 11]  # list
z = [(5, 11)]  # tuple inside a list
x, y = 5, 11  # shorthand for defining two vars separately, i.e., x=5 n y=11
tupleB = 5, 11
x, y = tupleB  # python assigns individual elements of tuple to vars
print(x, y)

# vars can start wid underscore (_)
# so, if any specific values needs to be ignored,
#     variable for that value can be named as _
#     informs that this variable/value is a placeholder, meant to be ignored
# Example:
person = ("Jas", "200", "39", "172")
name, _, age, height = person
print(name, age, height)

# in below case, all values except 1st get into *var
head, *tail = [1, 2, 3, 4, 5]  # *var helps store leftover values

# now in below case, all values except last get into *var
*head, tail = [1, 2, 3, 4, 5]  # *var helps store leftover values

# *, if used inside print, treats it as separate values n not as list
print(*head)

# functions : function is a callable variable, that won't execute unless invoked
# same wid variable; gets value assigned but doesn't get executed till invoked
# so basically defining a function doesn't run a function

# sequence of python execution for a function >>
def hello():         # 1. python interprets this 1st n ignored function body
    print("Hello!")  # 3. python runs this after function is invoked
hello()              # 2. upon invocation, python runs this next
#                         and then jumps to function body

# Don'ts in function
# 1. DO NOT overshadow global variable inside function scope
# 2. function cant be invoked before its definition

# def functa():
#    print("am inside function")
#    varA = varA + 5  # overriding global scope variable
# python creates space for new local variable, that shadows/overrides global var
# but since name is same for both global n local gives error like >>
# UnboundLocalError: cannot access local variable 'varA' where it is not associated with a value
#    print(f"value: {varA}")

# while coding, good practice to write pass inside function, when
# you know you need a function, but yet to decide what to put in function body

add(5, 3)  # Here, 5,3 r called arguments
# vars passed to function are created only during function invocation

# positional parameter/argument means definition & assignments based on position
# so, in above function, 5 is assigned to x; both at 1st position, n 3 to y
# so, position of argument affects value for parameter.
# keyword or named arguments are NOT positional. Example:
add(y=4, x=7)
# named arguments are very widely-used in python
# use named/keyword arguments wenevr possible to make code look easier to understand
# in a mix, positional arguments have to go 1st n then named arguments
add(5, y=3)  # works correctly

# add(x=4, 9)  # triggers error
# SyntaxError: positional argument follows keyword argument

# if you call a function with lesser arguments than number of parameters
# in the function definition,
# Python throws a `TypeError` indicating that the function is missing
# some required positional arguments.

# default pmtr values
# again, positional pmtr should be defined BEFORE default value declared

def multiply(x, y=9):  # makes y as optional now, with x still being required

multiply(6)
default_y = 5
multiply(6)  # will still give same result cuz default set at function creation
#               time, doesn't gets overridden later on

# functions returning values
# None is a spl value, meaning no value, missing or undeclared value
print(result)  # gives None, as thats default return value, if not specified

# return terminates the function, anything specified after return is ignored

# lambda functions, not vry common, usually we define fns
# its a diff. type of fn that doesnt has a name & is only used to return values
add_lambda = (lambda x, y: x + y)(6, 7)
print(add_lambda)
print((lambda x, y: x * y)(3, 7))

# diff. ways to achieve same thing, ur choice to pick most optimal
sequence = [2, 3, 6, 8, 9]
doubled = [x * 3 for x in sequence]  # list comprehension
doubled1 = [double(x) for x in sequence]  # list comprehension wid fn
doubled3 = [(lambda x: x * 7)(x) for x in sequence]  # list comprehension wid fn
doubled2 = list(map(lambda x: x * 5, sequence))  # pre-defined map fn using lambda

# list comprehension is faster than map
# only scenario whr map can be preferred is, if other lang.s do not support list comprehension
# lambda fns are difficult to keep track of, once programs grow

dictA = {user[1]: user for user in users}  # dictionary comprehension
# helps store user-specific key-value pairs
print(dictA)

def multiply(*args):  # define multiply fn that takes any no. of args
def apply(*args, operator):
    if operator == "+":
        print(args)
        return sum(args)
    elif operator == "*":
        #return multiply(args)  # returns tuple of tuples, cuz it takes no. as a tuple
        return multiply(*args)  # to fix it, use * here as well

numbers = [-1, -3, -5]
print(multiply(*numbers))  # can invoke this way as well
print(apply(1, 7, 6, 3, operator="+"))

add(x=dictB["x"], y=dictB["y"])  # instead of hard-coding n making this complex
add(**dictB)  # 2 asterisks can be used when
#                                  pmtr name of fn is same as key in dict.
#                                  very helpful in larger dictionaries

# keyword/named args r collected n put into dictionary

def named(*args):
    print(args)
def named1(**args):
    print(args)
def named2(**kwargs):
    print(kwargs)
def nice_output(**kwargs):
    named2(**kwargs)
    print("nicer")
    for arg, value in kwargs.items():
        print(f"{arg}: {value}")

details = {
    "name": "Jas",
    "age": 39
}
#named(**details)
named1(**details)
named2(**details)
nice_output(**details)

def both(*args, **kwargs):  # this syntax is used to accept unlimited no. of args

# *args    collects positional args in a tuple
# **kwargs collects named      args in a dictionary

# common example of above-defined both fn, is API fns like this >>
"""
def post(url, data=None, json=None, **kwargs):
    return request('post', url, data=data, json=json, **kwargs)
"""
get a JOB FAST